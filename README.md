# 八数码问题

使用 C++实现了八数码问题的解决方案，包括深度优先搜索、宽度优先搜索以及 A\*启发式搜索。

环境：在 x86-Win64 环境下调试及编译，`g++ == 8.1.0`、`gdb == 8.1`。由于使用了 C++`STL`部分新特性，建议使用 C++11 及以上的版本，或在编译时显示注明`-std=c++11`。

## 1.深度优先搜索

在八数码问题中，深度优先搜索并不是一种很好的解决办法。如果不进行最大递归深度的限制，程序有可能一直递归下去，直到堆栈超出内存。所以，在深度优先搜索中还需要加上最大递归深度的限制。

## 2.宽度优先搜索

在八数码问题中，宽度优先搜索比深度优先搜索效率更高。但是计算当前队列头可到达的状态时，是严格按照“上、下、左、右”移动的顺序来遍历的，没有选择性，是一种非启发式的搜索。

## 3.A\*启发式搜索算法

在 A\*搜索算法的实现中，核心是启发式函数的定义。这里给出了两个启发式函数：

### 3.1 曼哈顿距离

通过曼哈顿距离计算启发式函数$h(n)$的值，即所有数字到目标位置的曼哈顿距离之和。实际上在大多数情况下，如果从当前状态出发可以到达目标状态，那么$h(n)$的值等于从当前状态到目标状态，空格位置需要进行的交换次数。

### 3.2 欧式距离

通过欧式距离计算启发式函数$h(n)$的值，虽然直观意义上$h(n)$的值不再与空格位置的交换次数有关联，但是在八数码问题中二者也是等价的。当曼哈顿距离分别为 $1$,$3$,$4$ 时，欧氏距离为 $1$,$\sqrt{5}$,$2\sqrt{2}$，而当曼哈顿距离为 $2$ 时，欧式距离可能为 $2$，也可能为$\sqrt{2}$，这并不影响大小次序。

不论是哪一种启发式函数，具体进行实现时，都可以在 State 类中重载 < 运算符，借助优先级队列，使得$f(n)$的值越小的状态越靠近队列头部，这样就实现了代价越小的状态越先被搜索，这也正是 A\*搜索算法相较于宽度优先搜索的优点。

## 4.测试

假设起始状态如下：

```
1 5 7
4 2 8
6 3 0
```

目标状态如下：

```
1 2 3
4 5 6
7 8 0
```

四种算法的执行时间分别如下(以微秒为单位，不包括控制台输入时间):

| 算法                                  | 搜索时间 |
| ------------------------------------- | -------- |
| DFS                                   | 766570   |
| BFS                                   | 2844758  |
| A\*搜索(使用曼哈顿距离计算启发式函数) | 78845    |
| A\*搜索(使用欧式距离计算启发式函数)   | 141449   |
