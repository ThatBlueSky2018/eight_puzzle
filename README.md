# 八数码问题

## 一、实现功能

实现 8 数码问题的搜索算法，其中包括深度优先搜索、宽度优先搜索、启发式搜索。

## 二、环境

CPU: AMD Ryzen 5 4600U with Radeon Graphics 2.10 GHz

内存: 16.0 GB RAM

操作系统 : Windows11 22H2

编译环境 : x86-64 mingw64 `g++ == 8.1.0`、`gdb == 8.1`、`-std=c++14`

## 三、具体实现

### 1.深度优先搜索

深度优先搜索通过递归调用实现，核心包括以下三点：

- 记录已经访问过的状态节点
- 递归调用过程中不断记录从起始状态到当前状态的变化过程
- 为了避免递归次数过深出现堆栈超出限制的情况，限制最大递归次数

其中，限制最大递归次数是非常重要的，否则可能会因递归层数过深会导致堆栈内存超出限制。在定义了合适的最大递归层数之后，深度优先搜索可以表现出稍好的性能。

### 2.宽度优先搜索

宽度优先搜索通过队列实现，核心包括以下两点：

- 记录已经访问过的状态节点
- 循环过程中，记录当前状态由哪个过程转化而来

宽度优先搜索在计算当前队列头可到达的状态时，是严格按照“上、下、左、右”移动的顺序来遍历的，没有选择性，是一种非启发式的搜索。

### 3.A\*启发式搜索算法

A\*算法的本质，就是利用启发式函数，在宽度优先搜索的基础上增加了启发式搜索的功能。有如下定义：$f(n)=g(n)+h(n)$，其中$f(n)$表示初始状态到目标状态的代价函数，$g(n)$是初始状态到当前状态的实际代价，$h(n)$是当前状态到目标状态的预估代价，通过启发式函数计算。在 A\*搜索算法的实现中，核心是启发式函数的定义。这里给出了两个启发式函数：

#### 3.1 曼哈顿距离

通过曼哈顿距离计算启发式函数$h(n)$的值，即所有数字到目标位置的曼哈顿距离之和。在大多数情况下，如果从当前状态出发可以到达目标状态，那么$h(n)$的值等于从当前状态到目标状态，空格位置需要进行的交换次数。

#### 3.2 欧式距离

通过欧式距离计算启发式函数$h(n)$的值，虽然直观意义上$h(n)$的值不再与空格位置的交换次数有关联，但是二者的思想是相似的。就单个数字到目标位置来说，当曼哈顿距离分别为 $1$,$3$,$4$ 时，欧氏距离为 $1$,$\sqrt{5}$,$2\sqrt{2}$，而当曼哈顿距离为 $2$ 时，欧式距离可能为 $2$，也可能为$\sqrt{2}$，对应的大小次序实际上是一致的，在对所有数字的欧式距离求和之后，$h(n)$的值可能不同。

不论是哪一种启发式函数，具体进行实现时，核心部分都是在 State 类中重载 < 运算符，借助优先级队列，使得$f(n)$的值越小的状态越靠近队列头部，这样就实现了代价越小的状态越先被搜索，这也正是 A\*搜索算法相较于宽度优先搜索的优点。

## 四、测试结果

以下四组实验结果，分别描述了在特定的起始状态和目标状态下，四种算法的运行时间(以微秒为单位，不包括控制台输入时间)

#### 1.测试用例 1

起始状态如下：

```
1 5 7
4 2 8
6 3 0
```

目标状态如下：

```
1 2 3
4 5 6
7 8 0
```

运行时间：

| 算法                                  | 搜索时间 |
| ------------------------------------- | -------- |
| DFS                                   | 766570   |
| BFS                                   | 2844758  |
| A\*搜索(使用曼哈顿距离计算启发式函数) | 78845    |
| A\*搜索(使用欧式距离计算启发式函数)   | 141449   |

#### 2.测试用例 2

起始状态如下：

```
6 4 2
3 7 1
0 5 8
```

目标状态如下：

```
1 2 3
4 5 6
7 8 0
```

运行时间：

| 算法                                  | 搜索时间 |
| ------------------------------------- | -------- |
| DFS                                   | 1304513  |
| BFS                                   | 2026196  |
| A\*搜索(使用曼哈顿距离计算启发式函数) | 47908    |
| A\*搜索(使用欧式距离计算启发式函数)   | 78564    |

#### 3.测试用例 3

起始状态如下：

```
6 4 7
2 0 3
5 8 1
```

目标状态如下：

```
1 2 3
4 5 6
7 8 0
```

运行时间：

| 算法                                  | 搜索时间 |
| ------------------------------------- | -------- |
| DFS                                   | 973707   |
| BFS                                   | 3927639  |
| A\*搜索(使用曼哈顿距离计算启发式函数) | 94782    |
| A\*搜索(使用欧式距离计算启发式函数)   | 78155    |

#### 4.测试用例 4

起始状态如下：

```
5 1 8
3 7 4
2 6 0
```

目标状态如下：

```
1 2 3
4 5 6
7 8 0
```

运行时间：

| 算法                                  | 搜索时间 |
| ------------------------------------- | -------- |
| DFS                                   | 943049   |
| BFS                                   | 3749182  |
| A\*搜索(使用曼哈顿距离计算启发式函数) | 94157    |
| A\*搜索(使用欧式距离计算启发式函数)   | 267793   |

## 五、结果分析

通过对四组测试用例的分析，可以得出如下三点结论：

- 启发式搜索的性能高于 DFS 和 BFS
- 在大多数情况下，DFS 的性能优于 BFS，这是因为对 DFS 进行了最大递归深度限制，使其表现出了较好的性能
- 在启发式搜索中，大多数情况下，使用曼哈顿距离计算启发式函数的性能优于使用欧式距离计算启发式函数，这是因为欧氏距离涉及到平方计算与开方计算，在计算$h(n)$的值时耗费了更多的时间
